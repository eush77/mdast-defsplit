/**
 * @typedef {import('mdast').Root} Root
 * @typedef {import('mdast').Content|Root} Node
 * @typedef {import('mdast').Heading} Heading
 * @typedef {import('mdast').Definition} Definition
 *
 * @typedef Options
 *   Configuration.
 * @property {string|string[]} [id=[]]
 *   Identifiers to use for new definitions instead of autogenerated ones.
 */

import {URL} from 'url'
import path from 'path'
import {Index} from 'unist-util-index'

/**
 * Plugin to change links and images to references with separate definitions.
 *
 * @type {import('unified').Plugin<[Options?] | void[], Root>}
 */
export default function remarkDefsplit(options = {}) {
  const id = options.id || []
  const ids = (Array.isArray(id) ? id : [id]).map((d) => String(d))

  return (tree) => {
    const definitionsById = new Index('identifier', tree, 'definition')
    const definitionsByUrl = new Index('url', tree, 'definition')
    /** @type {Array.<Heading|Definition>} */
    const definitions = []
    /** @type {Record<string, number>} */
    const hosts = Object.create(null)

    postorder(tree)

    tree.children.push(...definitions)

    /**
     * @param {Node} node
     * @returns {Node|Node[]}
     */
    function postorder(node) {
      /** @type {Array.<Node|Heading>|undefined} */
      let nodes

      if ('children' in node) {
        // @ts-expect-error: assume content model is mapped correctly.
        node.children = node.children.flatMap((node) => postorder(node))
      }

      if (node.type === 'definition' || node.type === 'heading') {
        nodes = definitions.concat(node)
        definitions.length = 0
        return nodes
      }

      if (node.type === 'link') {
        return {
          type: 'linkReference',
          referenceType: 'full',
          identifier: identifier(node.url, node.title),
          children: node.children
        }
      }

      if (node.type === 'image') {
        return {
          type: 'imageReference',
          referenceType: 'full',
          identifier: identifier(node.url, node.title),
          alt: node.alt
        }
      }

      return node
    }

    /**
     * @param {string} link
     * @param {string|null|undefined} title
     * @returns {string}
     */
    function identifier(link, title) {
      /** @type {string|null|undefined} */
      let identifier

      definitionsByUrl.get(link).some((node) => {
        const def = /** @type {Definition} */ (node)
        if (def.title === title) {
          identifier = def.identifier
          return true
        }

        return false
      })

      if (!identifier) {
        identifier = ids.shift()

        if (!identifier) {
          /** @type {string|undefined} */
          let host

          try {
            host = new URL(link).host
          } catch {}

          host = host ? path.parse(host).name : ''

          // `Math.trunc` doesnâ€™t work.
          /* eslint-disable-next-line unicorn/prefer-math-trunc */
          hosts[host] |= 0

          do {
            identifier = (host ? host + '-' : '') + ++hosts[host]
          } while (definitionsById.get(identifier).length > 0)
        }

        /** @type {Definition} */
        const definition = {
          type: 'definition',
          identifier,
          title,
          url: link
        }

        definitions.push(definition)
        definitionsById.add(definition)
        definitionsByUrl.add(definition)
      }

      return identifier
    }
  }
}
