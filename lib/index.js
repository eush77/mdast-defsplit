/**
 * @typedef {import('mdast').Definition} Definition
 * @typedef {import('mdast').Root} Root
 * @typedef {import('unist-util-visit').BuildVisitor<Root>} Visitor
 */

/**
 * @typedef Options
 *   Configuration (optional).
 * @property {ReadonlyArray<string> | string} [id=[]]
 *   IDs to use for new definitions instead of autogenerated ones (optional);
 *   when given one ID, then the first link or image will use that ID, when
 *   another link or image is seen, it’ll get an autogenerated ID.
 */

import {SKIP, visit} from 'unist-util-visit'

/** @type {Readonly<Options>} */
const emptyOptions = {}

/**
 * Change links and images to references with separate definitions.
 *
 * @param {Readonly<Options> | null | undefined} [options]
 *   Configuration (optional).
 * @returns
 *   Transform.
 */
export default function remarkDefsplit(options) {
  const settings = options || emptyOptions
  const id = settings.id

  /**
   * Transform.
   *
   * @param {Root} tree
   *   Tree.
   * @returns {undefined}
   *   Nothing.
   */
  return function (tree) {
    /** @type {Array<string>} */
    // type-coverage:ignore-next-line
    const ids = Array.isArray(id) ? [...id] : id ? [id] : []
    /** @type {Set<string>} */
    const definedIds = new Set()
    /** @type {Map<string, Map<string, string>>} */
    const definedUrls = new Map()
    /** @type {Map<string, number>} */
    const counts = new Map()

    visit(tree, 'definition', function (node) {
      const id = node.identifier
      const title = node.title || ''

      definedIds.add(id)

      let definedTitles = definedUrls.get(node.url)
      if (!definedTitles) {
        definedTitles = new Map()
        definedUrls.set(node.url, definedTitles)
      }

      definedTitles.set(title, id)
    })

    /** @type {Array<Definition>} */
    const queue = []

    // Walk the tree, replacing images/links, queueing definitions, flushing
    // them at definitions/headings.
    visit(tree, visitor)

    // Flush remaining definitions.
    tree.children.push(...queue)

    // Done.

    /** @type {Visitor} */
    function visitor(node, index, parent) {
      if (!parent || typeof index !== 'number') {
        return
      }

      // Flush the queue at definitions and headings.
      if (node.type === 'definition' || node.type === 'heading') {
        const next = index + queue.length
        parent.children.splice(index, 0, ...queue)
        queue.length = 0
        return next + 1
      }

      // Replace images/definitions.
      if (node.type === 'image' || node.type === 'link') {
        // Preorder on links, which can have images.
        // This doesn’t stack overflow because we exit w/o parent.
        visit(node, visitor)

        const url = node.url
        const title = node.title || ''
        let definedTitles = definedUrls.get(url)

        if (!definedTitles) {
          definedTitles = new Map()
          definedUrls.set(url, definedTitles)
        }

        let identifier = definedTitles.get(title)

        if (!identifier) {
          identifier = ids.shift()

          if (!identifier) {
            /** @type {string | undefined} */
            let host

            try {
              host = new URL(url).host
            } catch {}

            host = host ? host.split('.')[0] : ''

            let count = counts.get(host) || 0

            do {
              count++
              identifier = (host ? host + '-' : '') + count
            } while (definedIds.has(identifier))

            counts.set(host, count)
          }

          definedIds.add(identifier)
          definedTitles.set(title, identifier)
          queue.push({type: 'definition', identifier, title, url})
        }

        parent.children[index] =
          node.type === 'link'
            ? {
                type: 'linkReference',
                referenceType: 'full',
                identifier,
                children: node.children
              }
            : {
                type: 'imageReference',
                referenceType: 'full',
                identifier,
                alt: node.alt
              }

        return SKIP
      }
    }
  }
}
